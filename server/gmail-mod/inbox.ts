import { getUncachableGmailClient } from './tokens';

export async function checkThreadForReplies(userId: number, threadId: string, originalMessageId: string) { const gmail = await getUncachableGmailClient(userId); try { const response = await gmail.users.threads.get({ userId: 'me', id: threadId, format: 'full' }); const messages = response.data.messages || []; if (messages.length > 1) { const replyMessages = messages.filter(m => m.id !== originalMessageId); if (replyMessages.length > 0) { const latestReply = replyMessages[replyMessages.length - 1]; let replyContent = ''; if (latestReply.payload?.parts) { const textPart = latestReply.payload.parts.find(p => p.mimeType === 'text/plain'); if (textPart?.body?.data) replyContent = Buffer.from(textPart.body.data, 'base64').toString('utf-8'); } else if (latestReply.payload?.body?.data) { replyContent = Buffer.from(latestReply.payload.body.data, 'base64').toString('utf-8'); } return { hasReply: true, replyMessageId: latestReply.id, replyContent }; } } return { hasReply: false }; } catch (error) { console.error('Error checking Gmail thread for replies:', error); return { hasReply: false }; } }

export async function checkInboxForContactEmails(userId: number, contactEmail: string, afterDate?: Date, originalSubject?: string) {
  const gmail = await getUncachableGmailClient(userId); try { let query = `from:${contactEmail}`; if (afterDate) { const year = afterDate.getFullYear(); const month = String(afterDate.getMonth() + 1).padStart(2, '0'); const day = String(afterDate.getDate()).padStart(2, '0'); query += ` after:${year}/${month}/${day}`; } if (originalSubject) { let cleanSubject = originalSubject.replace(/^(Re:|RE:|Fwd:|FWD:)\s*/gi, '').replace(/"/g, '\\"').replace(/\s+/g, ' ').trim(); if (cleanSubject.length > 0) query += ` subject:"${cleanSubject}"`; } const response = await gmail.users.messages.list({ userId: 'me', q: query, maxResults: 10 }); const messages = response.data.messages || []; if (messages.length === 0) return { hasReply: false, emails: [] };
  const emailDetails = await Promise.all(messages.map(async (msg) => { const messageData = await gmail.users.messages.get({ userId: 'me', id: msg.id! }); let emailContent = '', subject = '', receivedDate = ''; const headers = messageData.data.payload?.headers || []; const subjectHeader = headers.find(h => h.name === 'Subject'); const dateHeader = headers.find(h => h.name === 'Date'); const fromHeader = headers.find(h => h.name === 'From'); if (subjectHeader) subject = subjectHeader.value || ''; if (dateHeader) receivedDate = dateHeader.value || ''; let sender = ''; if (fromHeader?.value) { const match = fromHeader.value.match(/<(.+?)>/) || fromHeader.value.match(/([^\s<>]+@[^\s<>]+)/); sender = match ? match[1].toLowerCase().trim() : fromHeader.value.toLowerCase().trim(); } if (messageData.data.payload?.parts) { const textPart = messageData.data.payload.parts.find(p => p.mimeType === 'text/plain'); if (textPart?.body?.data) emailContent = Buffer.from(textPart.body.data, 'base64').toString('utf-8'); } else if (messageData.data.payload?.body?.data) { emailContent = Buffer.from(messageData.data.payload.body.data, 'base64').toString('utf-8'); } return { messageId: msg.id!, threadId: msg.threadId, subject, content: emailContent, receivedDate: receivedDate ? new Date(receivedDate) : new Date(), sender }; })); return { hasReply: emailDetails.length > 0, emails: emailDetails, latestEmail: emailDetails[0] }; } catch (error) { console.error('Error checking inbox for contact emails:', error); return { hasReply: false, emails: [], error: error instanceof Error ? error.message : 'Unknown error' }; }
}
