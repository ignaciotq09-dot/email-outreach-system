import { getUncachableGmailClient, getGmailUserEmail } from '../../gmail';
import type { ReplyDetectionResult, ThreadCheckOptions } from './types';
import { isAutoReplyMessage, extractSenderEmail, emailsMatch, extractMessageContent, stripQuotedContent } from './helpers';

export async function checkThreadForAuthenticReplies(options: ThreadCheckOptions): Promise<ReplyDetectionResult> {
  try { const { threadId, originalMessageId, sentAt, recipientEmail } = options; const gmail = await getUncachableGmailClient(); const ourEmail = await getGmailUserEmail(); if (!ourEmail) { console.error('[ReplyDetection] Could not get our email address'); return { hasReply: false }; }
  console.log(`[ReplyDetection] Checking thread ${threadId} for replies from ${recipientEmail}`); const thread = await gmail.users.threads.get({ userId: 'me', id: threadId, format: 'full' }); const messages = thread.data.messages || []; console.log(`[ReplyDetection] Thread has ${messages.length} total messages`);
  const authenticReplies = []; for (const message of messages) { if (message.id === originalMessageId) { console.log(`[ReplyDetection] Skipping original message ${message.id}`); continue; } const headers = message.payload?.headers || []; const dateHeader = headers.find(h => h.name === 'Date'); const messageDate = dateHeader?.value ? new Date(dateHeader.value) : null; if (messageDate && messageDate < sentAt) continue; if (isAutoReplyMessage(headers)) continue; const fromHeader = headers.find(h => h.name === 'From'); if (!fromHeader?.value) continue; const senderEmail = extractSenderEmail(fromHeader.value); console.log(`[ReplyDetection] Message ${message.id} from: ${senderEmail}`); if (emailsMatch(senderEmail, ourEmail)) continue;
  if (emailsMatch(senderEmail, recipientEmail)) { const inReplyTo = headers.find(h => h.name === 'In-Reply-To')?.value; const references = headers.find(h => h.name === 'References')?.value; if (inReplyTo) console.log(`[ReplyDetection] In-Reply-To: ${inReplyTo}`); if (references) console.log(`[ReplyDetection] References: ${references}`); console.log(`[ReplyDetection] ✓ Found authentic reply from ${senderEmail} in message ${message.id}`); const content = message.payload ? extractMessageContent(message.payload) : ''; const cleanContent = stripQuotedContent(content); authenticReplies.push({ messageId: message.id, sender: senderEmail, content: cleanContent, receivedAt: messageDate || new Date(), internalDate: message.internalDate }); } else { console.log(`[ReplyDetection] Sender ${senderEmail} doesn't match recipient ${recipientEmail}`); } }
  if (authenticReplies.length > 0) { authenticReplies.sort((a, b) => { const aDate = a.internalDate ? parseInt(a.internalDate) : 0; const bDate = b.internalDate ? parseInt(b.internalDate) : 0; return bDate - aDate; }); const latestReply = authenticReplies[0]; console.log(`[ReplyDetection] ✓ Found ${authenticReplies.length} authentic reply(ies), returning latest`); return { hasReply: true, replyMessageId: latestReply.messageId || undefined, replyContent: latestReply.content, replyReceivedAt: latestReply.receivedAt, sender: latestReply.sender, isAutoReply: false }; }
  console.log(`[ReplyDetection] ✗ No authentic replies found in thread`); return { hasReply: false }; } catch (error: any) { console.error('[ReplyDetection] Error checking thread:', error); if (error?.code === 403 || error?.message?.includes('Missing access token')) throw error; return { hasReply: false }; }
}
