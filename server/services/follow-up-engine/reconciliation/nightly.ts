import { db } from "../../../db";
import { eq, and, sql, or, lt } from "drizzle-orm";
import { sentEmails, campaigns, campaignContacts, contacts, followUpJobs, followUpReconciliation } from "@shared/schema";
import { createJob } from "../job-queue";
import type { ReconciliationResult } from "../types";
import { checkForMissedFollowUp } from "./checker";

export async function runNightlyReconciliation(): Promise<ReconciliationResult> {
  const startTime = Date.now(); const errors: Array<{ type: string; message: string; context?: any }> = []; console.log('[FollowUpReconciliation] Starting nightly reconciliation...'); let emailsChecked = 0, missedFollowUpsFound = 0, jobsCreated = 0, jobsRetried = 0, anomaliesLogged = 0;
  try { const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const allActiveCampaigns = await db.select({ campaign: campaigns, campaignContact: campaignContacts, contact: contacts, sentEmail: sentEmails }).from(campaigns).innerJoin(campaignContacts, eq(campaignContacts.campaignId, campaigns.id)).innerJoin(contacts, eq(campaignContacts.contactId, contacts.id)).innerJoin(sentEmails, eq(campaignContacts.sentEmailId, sentEmails.id)).where(and(eq(campaigns.status, 'sent'), sql`${campaigns.followUpSequenceId} IS NOT NULL`, sql`${sentEmails.sentAt} >= ${thirtyDaysAgo}`, eq(sentEmails.replyReceived, false))).limit(1000);
  for (const row of allActiveCampaigns) { emailsChecked++; try { const missedResult = await checkForMissedFollowUp(row.campaign, row.contact, row.sentEmail); if (missedResult.missed) { missedFollowUpsFound++; const existingJob = await db.select().from(followUpJobs).where(and(eq(followUpJobs.originalEmailId, row.sentEmail.id), eq(followUpJobs.stepNumber, missedResult.stepNumber), or(eq(followUpJobs.status, 'pending'), eq(followUpJobs.status, 'queued'), eq(followUpJobs.status, 'sending'), eq(followUpJobs.status, 'sent')))).limit(1); if (existingJob.length === 0) { await createJob({ campaignId: row.campaign.id, contactId: row.contact.id, originalEmailId: row.sentEmail.id, sequenceId: row.campaign.followUpSequenceId || undefined, stepId: missedResult.stepId, stepNumber: missedResult.stepNumber, scheduledFor: new Date(), subject: missedResult.subject, body: missedResult.body, metadata: { userId: row.campaign.userId, source: 'nightly_reconciliation', originalDueDate: missedResult.dueDate?.toISOString() } }); jobsCreated++; } } } catch (error: any) { errors.push({ type: 'check_error', message: error?.message || 'Unknown error', context: { campaignId: row.campaign.id, contactId: row.contact.id } }); anomaliesLogged++; } }
  const deadJobs = await db.select().from(followUpJobs).where(and(eq(followUpJobs.status, 'failed'), lt(followUpJobs.lastAttemptAt, new Date(Date.now() - 48 * 60 * 60 * 1000)), sql`${followUpJobs.attemptCount} >= ${followUpJobs.maxAttempts}`)).limit(100); for (const job of deadJobs) anomaliesLogged++; } catch (error: any) { errors.push({ type: 'reconciliation_error', message: error?.message || 'Unknown error' }); }
  const durationMs = Date.now() - startTime; await db.insert(followUpReconciliation).values({ runType: 'nightly', completedAt: new Date(), emailsChecked, missedFollowUpsFound, jobsCreated, jobsRetried, anomaliesLogged, errors: errors.length > 0 ? errors : undefined, summary: `Full sweep: ${emailsChecked} emails, ${missedFollowUpsFound} missed, ${jobsCreated} jobs created` }); console.log(`[FollowUpReconciliation] Nightly complete in ${durationMs}ms`); return { runType: 'nightly', emailsChecked, missedFollowUpsFound, jobsCreated, jobsRetried, anomaliesLogged, errors, durationMs };
}
