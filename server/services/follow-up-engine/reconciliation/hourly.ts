import { db } from "../../../db";
import { eq, and, sql, or, lt } from "drizzle-orm";
import { sentEmails, campaigns, campaignContacts, contacts, followUpJobs, followUpReconciliation } from "@shared/schema";
import { createJob } from "../job-queue";
import type { ReconciliationResult } from "../types";
import { checkForMissedFollowUp } from "./checker";

export async function runHourlyReconciliation(): Promise<ReconciliationResult> {
  const startTime = Date.now(); const errors: Array<{ type: string; message: string; context?: any }> = []; console.log('[FollowUpReconciliation] Starting hourly reconciliation...'); let emailsChecked = 0, missedFollowUpsFound = 0, jobsCreated = 0, jobsRetried = 0, anomaliesLogged = 0;
  try { const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const recentCampaigns = await db.select({ campaign: campaigns, campaignContact: campaignContacts, contact: contacts, sentEmail: sentEmails }).from(campaigns).innerJoin(campaignContacts, eq(campaignContacts.campaignId, campaigns.id)).innerJoin(contacts, eq(campaignContacts.contactId, contacts.id)).innerJoin(sentEmails, eq(campaignContacts.sentEmailId, sentEmails.id)).where(and(eq(campaigns.status, 'sent'), sql`${campaigns.followUpSequenceId} IS NOT NULL`, sql`${sentEmails.sentAt} >= ${oneDayAgo}`, eq(sentEmails.replyReceived, false))).limit(200);
  for (const row of recentCampaigns) { emailsChecked++; try { const missedResult = await checkForMissedFollowUp(row.campaign, row.contact, row.sentEmail); if (missedResult.missed) { missedFollowUpsFound++; const existingJob = await db.select().from(followUpJobs).where(and(eq(followUpJobs.originalEmailId, row.sentEmail.id), eq(followUpJobs.stepNumber, missedResult.stepNumber), or(eq(followUpJobs.status, 'pending'), eq(followUpJobs.status, 'queued'), eq(followUpJobs.status, 'sending'), eq(followUpJobs.status, 'sent')))).limit(1); if (existingJob.length === 0) { await createJob({ campaignId: row.campaign.id, contactId: row.contact.id, originalEmailId: row.sentEmail.id, sequenceId: row.campaign.followUpSequenceId || undefined, stepId: missedResult.stepId, stepNumber: missedResult.stepNumber, scheduledFor: new Date(), subject: missedResult.subject, body: missedResult.body, metadata: { userId: row.campaign.userId, source: 'hourly_reconciliation', originalDueDate: missedResult.dueDate?.toISOString() } }); jobsCreated++; } } } catch (error: any) { errors.push({ type: 'check_error', message: error?.message || 'Unknown error', context: { campaignId: row.campaign.id, contactId: row.contact.id } }); anomaliesLogged++; } }
  const stuckJobs = await db.select().from(followUpJobs).where(and(eq(followUpJobs.status, 'sending'), lt(followUpJobs.startedAt, new Date(Date.now() - 30 * 60 * 1000)))).limit(50); for (const job of stuckJobs) { await db.update(followUpJobs).set({ status: 'queued', startedAt: null }).where(eq(followUpJobs.id, job.id)); jobsRetried++; } } catch (error: any) { errors.push({ type: 'reconciliation_error', message: error?.message || 'Unknown error' }); }
  const durationMs = Date.now() - startTime; await db.insert(followUpReconciliation).values({ runType: 'hourly', completedAt: new Date(), emailsChecked, missedFollowUpsFound, jobsCreated, jobsRetried, anomaliesLogged, errors: errors.length > 0 ? errors : undefined, summary: `Hourly: ${emailsChecked} checked, ${missedFollowUpsFound} missed, ${jobsCreated} created, ${jobsRetried} retried` }); console.log(`[FollowUpReconciliation] Hourly complete in ${durationMs}ms`); return { runType: 'hourly', emailsChecked, missedFollowUpsFound, jobsCreated, jobsRetried, anomaliesLogged, errors, durationMs };
}
