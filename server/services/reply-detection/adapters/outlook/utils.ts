import type { ProviderMessage } from "../../types";

export function extractEmailFromRecipient(recipient: any): string { if (!recipient) return ''; if (typeof recipient === 'string') return recipient.toLowerCase().trim(); return recipient.emailAddress?.address?.toLowerCase()?.trim() || ''; }

export function isAutoReplyMessage(message: any): boolean { if (message.internetMessageHeaders) { for (const header of message.internetMessageHeaders) { const name = header.name?.toLowerCase(); const value = header.value?.toLowerCase() || ''; if (name === 'auto-submitted' && value !== 'no') return true; if (name === 'x-auto-response-suppress') return true; if (name === 'x-autoreply' || name === 'x-autorespond') return true; if (name === 'precedence' && (value === 'auto_reply' || value === 'bulk')) return true; } } const messageClass = message.itemClass || ''; if (messageClass.includes('IPM.Note.Rules.OofTemplate')) return true; return false; }

export function extractMessageContent(message: any): { text: string; html?: string } { const body = message.body || {}; const content = body.content || ''; const contentType = body.contentType?.toLowerCase() || 'text'; if (contentType === 'html') { const text = content.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim(); return { text, html: content }; } return { text: content }; }

export function convertToProviderMessage(message: any): ProviderMessage { const content = extractMessageContent(message); const from = extractEmailFromRecipient(message.from); const to = message.toRecipients?.map(extractEmailFromRecipient).join(', ') || ''; const cc = message.ccRecipients?.map(extractEmailFromRecipient).join(', ') || ''; const headers = message.internetMessageHeaders || []; const getHeader = (name: string) => headers.find((h: any) => h.name?.toLowerCase() === name.toLowerCase())?.value || undefined; return { id: message.id, threadId: message.conversationId, subject: message.subject || '', snippet: message.bodyPreview || '', from, to, cc, date: new Date(message.receivedDateTime), labelIds: [], rawHeaders: { 'message-id': getHeader('message-id'), 'in-reply-to': getHeader('in-reply-to'), references: getHeader('references') }, bodyText: content.text, bodyHtml: content.html, isAutoReply: isAutoReplyMessage(message), isRead: message.isRead }; }
