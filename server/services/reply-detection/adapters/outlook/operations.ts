import type { ProviderMessage, LayerHealthStatus } from "../../types";
import { getOutlookClient } from './tokens';
import { convertToProviderMessage } from './utils';

export async function checkHealth(userId: number): Promise<LayerHealthStatus> { const startTime = Date.now(); try { const client = await getOutlookClient(userId); const profile = await client.api('/me').select('mail,userPrincipalName').get(); if (!profile) return { layer: 'outlook', healthy: false, lastCheckedAt: new Date(), errorMessage: 'Failed to reach Microsoft Graph API', responseTimeMs: Date.now() - startTime }; return { layer: 'outlook', healthy: true, lastCheckedAt: new Date(), responseTimeMs: Date.now() - startTime }; } catch (error: any) { return { layer: 'outlook', healthy: false, lastCheckedAt: new Date(), errorMessage: error?.message || 'Unknown error', responseTimeMs: Date.now() - startTime }; } }

export async function getUserEmail(userId: number): Promise<string | null> { try { const client = await getOutlookClient(userId); const profile = await client.api('/me').select('mail,userPrincipalName').get(); return profile.mail || profile.userPrincipalName || null; } catch (error) { console.error('[OutlookAdapter] Error getting user email:', error); return null; } }

export async function fetchThread(userId: number, conversationId: string): Promise<{ messages: ProviderMessage[]; threadId: string } | null> { try { const client = await getOutlookClient(userId); const response = await client.api('/me/messages').filter(`conversationId eq '${conversationId}'`).select('id,conversationId,from,toRecipients,ccRecipients,bccRecipients,subject,body,bodyPreview,receivedDateTime,internetMessageHeaders,itemClass').orderby('receivedDateTime asc').top(50).get(); if (!response || !response.value) return null; const messages = response.value.map(convertToProviderMessage); return { messages, threadId: conversationId }; } catch (error) { console.error('[OutlookAdapter] Error fetching thread:', error); return null; } }

export async function searchMessages(userId: number, query: string, options?: { maxResults?: number; afterDate?: Date }): Promise<ProviderMessage[]> { try { const client = await getOutlookClient(userId); let filter = ''; const fromMatch = query.match(/from:([^\s]+)/i); if (fromMatch) filter = `from/emailAddress/address eq '${fromMatch[1]}'`; if (options?.afterDate) { const dateFilter = `receivedDateTime ge ${options.afterDate.toISOString()}`; filter = filter ? `${filter} and ${dateFilter}` : dateFilter; } let request = client.api('/me/messages').select('id,conversationId,from,toRecipients,ccRecipients,bccRecipients,subject,body,bodyPreview,receivedDateTime,internetMessageHeaders,itemClass').orderby('receivedDateTime desc').top(options?.maxResults || 50); if (filter) request = request.filter(filter); const response = await request.get(); if (!response || !response.value) return []; return response.value.map(convertToProviderMessage); } catch (error) { console.error('[OutlookAdapter] Error searching messages:', error); return []; } }
