import type { ProviderMessage } from "../../types";

export function extractEmailFromHeader(value: string): string { if (!value) return ''; const match = value.match(/<([^>]+)>/) || value.match(/([^\s]+@[^\s]+)/); return match ? match[1].toLowerCase().trim() : value.toLowerCase().trim(); }

export function isAutoReplyMessage(headers: Array<{ name?: string | null; value?: string | null }>): boolean { for (const header of headers) { const name = header.name?.toLowerCase(); const value = header.value?.toLowerCase() || ''; if (name === 'auto-submitted' && value !== 'no') return true; if (name === 'x-auto-response-suppress') return true; if (name === 'x-autoreply' || name === 'x-autorespond') return true; if (name === 'precedence' && (value === 'auto_reply' || value === 'bulk' || value === 'junk')) return true; if (name === 'x-mailer' && value.includes('vacation') || value.includes('autoresponder')) return true; } return false; }

export function extractMessageContent(payload: any): { text: string; html?: string } { let text = ''; let html: string | undefined; function extractFromParts(parts: any[]): void { for (const part of parts) { if (part.mimeType === 'text/plain' && part.body?.data) { text += Buffer.from(part.body.data, 'base64').toString('utf-8'); } else if (part.mimeType === 'text/html' && part.body?.data) { html = Buffer.from(part.body.data, 'base64').toString('utf-8'); } else if (part.parts) { extractFromParts(part.parts); } } } if (payload.parts) extractFromParts(payload.parts); else if (payload.body?.data) text = Buffer.from(payload.body.data, 'base64').toString('utf-8'); return { text: text.trim(), html }; }

export function convertToProviderMessage(message: any): ProviderMessage { const headers = message.payload?.headers || []; const getHeader = (name: string) => headers.find((h: any) => h.name?.toLowerCase() === name.toLowerCase())?.value || ''; const content = extractMessageContent(message.payload); const from = extractEmailFromHeader(getHeader('From')); const to = extractEmailFromHeader(getHeader('To')); return { id: message.id, threadId: message.threadId, subject: getHeader('Subject'), snippet: message.snippet || '', from, to, date: new Date(parseInt(message.internalDate) || Date.now()), labelIds: message.labelIds || [], rawHeaders: { 'message-id': getHeader('Message-ID'), 'in-reply-to': getHeader('In-Reply-To') || undefined, references: getHeader('References') || undefined }, bodyText: content.text, bodyHtml: content.html, isAutoReply: isAutoReplyMessage(headers), isRead: !message.labelIds?.includes('UNREAD') }; }
