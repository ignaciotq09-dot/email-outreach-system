import type { ProviderMessage, LayerHealthStatus } from "../../types";
import { withRetry } from "../../retry";
import { getGmailClient } from './tokens';
import { convertToProviderMessage } from './utils';

export async function checkHealth(userId: number): Promise<LayerHealthStatus> {
  const startTime = Date.now(); try { const gmail = await getGmailClient(userId); const profile = await withRetry(() => gmail.users.getProfile({ userId: 'me' }), 'Gmail health check', { maxRetries: 1, initialDelay: 500 }); if (!profile) return { layer: 'gmail', healthy: false, lastCheckedAt: new Date(), errorMessage: 'Failed to reach Gmail API', responseTimeMs: Date.now() - startTime }; return { layer: 'gmail', healthy: true, lastCheckedAt: new Date(), responseTimeMs: Date.now() - startTime }; } catch (error: any) { return { layer: 'gmail', healthy: false, lastCheckedAt: new Date(), errorMessage: error?.message || 'Unknown error', responseTimeMs: Date.now() - startTime }; }
}

export async function getUserEmail(userId: number): Promise<string | null> { try { const gmail = await getGmailClient(userId); const profile = await gmail.users.getProfile({ userId: 'me' }); return profile.data.emailAddress || null; } catch (error) { console.error('[GmailAdapter] Error getting user email:', error); return null; } }

export async function fetchThread(userId: number, threadId: string): Promise<{ messages: ProviderMessage[]; threadId: string } | null> { try { const gmail = await getGmailClient(userId); const thread = await withRetry(() => gmail.users.threads.get({ userId: 'me', id: threadId, format: 'full' }), `Fetch thread ${threadId}`, { maxRetries: 3, initialDelay: 500 }); if (!thread) return null; const messages = (thread.data.messages || []).map(convertToProviderMessage); return { messages, threadId: thread.data.id || threadId }; } catch (error) { console.error('[GmailAdapter] Error fetching thread:', error); return null; } }

export async function searchMessages(userId: number, query: string, options?: { maxResults?: number; afterDate?: Date }): Promise<ProviderMessage[]> { try { const gmail = await getGmailClient(userId); let fullQuery = query; if (options?.afterDate) { const timestamp = Math.floor(options.afterDate.getTime() / 1000); fullQuery += ` after:${timestamp}`; } const response = await withRetry(() => gmail.users.messages.list({ userId: 'me', q: fullQuery, maxResults: options?.maxResults || 50 }), `Search messages: ${fullQuery}`, { maxRetries: 3, initialDelay: 500 }); if (!response || !response.data.messages) return []; const messages: ProviderMessage[] = []; for (const msg of response.data.messages) { const fullMessage = await withRetry(() => gmail.users.messages.get({ userId: 'me', id: msg.id!, format: 'full' }), `Get message ${msg.id}`, { maxRetries: 2, initialDelay: 300 }); if (fullMessage) messages.push(convertToProviderMessage(fullMessage.data)); } return messages; } catch (error) { console.error('[GmailAdapter] Error searching messages:', error); return []; } }
