import type { DetectionResult } from "../../types";
import { withRetry } from "../../retry";
import type { HistoryListResponse, MessageResponse } from './types';
import { getHistoryCheckpoint, updateHistoryCheckpoint } from './checkpoint';
import { isMessageFromContact, decodeBase64Url, extractTextFromParts } from './utils';

export async function scanHistoryForReplies(gmail: any, userEmail: string, contactEmail: string, sentAfter: Date): Promise<DetectionResult> {
  try { const startHistoryId = await getHistoryCheckpoint(userEmail); if (!startHistoryId) { const profile = await withRetry(() => gmail.users.getProfile({ userId: 'me' })); if (profile.data.historyId) await updateHistoryCheckpoint(userEmail, profile.data.historyId); return { found: false, replies: [], searchMetadata: { layer: "gmail-history", queriesRun: ["users.getProfile (init)"], pagesChecked: 0, messagesScanned: 0, notes: "Initialized history checkpoint" } }; }
  const replies = []; let pageToken: string | undefined; let pagesChecked = 0; let messagesScanned = 0; let latestHistoryId = startHistoryId; const queriesRun = [];
  do { pagesChecked++; queriesRun.push(`users.history.list (page ${pagesChecked})`); const historyResponse: HistoryListResponse = await withRetry(() => gmail.users.history.list({ userId: 'me', startHistoryId, historyTypes: ['messageAdded'], labelId: 'INBOX', pageToken, maxResults: 100 })).then(r => r.data); if (historyResponse.historyId) latestHistoryId = historyResponse.historyId;
  if (historyResponse.history) { for (const historyItem of historyResponse.history) { if (historyItem.messagesAdded) { for (const added of historyItem.messagesAdded) { messagesScanned++; if (!added.message.labelIds?.includes('INBOX')) continue; queriesRun.push(`users.messages.get (${added.message.id})`); const messageResponse: MessageResponse = await withRetry(() => gmail.users.messages.get({ userId: 'me', id: added.message.id })).then(r => r.data);
  if (isMessageFromContact(messageResponse.payload.headers, contactEmail, userEmail)) { let content = messageResponse.snippet; if (messageResponse.payload.parts) { const fullText = extractTextFromParts(messageResponse.payload.parts); if (fullText) content = fullText; } else if (messageResponse.payload.body?.data) { content = decodeBase64Url(messageResponse.payload.body.data); } const subjectHeader = messageResponse.payload.headers.find(h => h.name.toLowerCase() === "subject"); replies.push({ gmailMessageId: messageResponse.id, gmailThreadId: messageResponse.threadId, subject: subjectHeader?.value || '', content, receivedAt: new Date(parseInt(messageResponse.internalDate)) }); } } } } } pageToken = historyResponse.nextPageToken; } while (pageToken && pagesChecked < 5);
  await updateHistoryCheckpoint(userEmail, latestHistoryId); return { found: replies.length > 0, replies, searchMetadata: { layer: "gmail-history", queriesRun, pagesChecked, messagesScanned, notes: `Checked history from ${startHistoryId} to ${latestHistoryId}` } }; } catch (error: any) { if (error.message?.includes('startHistoryId') || error.code === 404) { const profile = await withRetry(() => gmail.users.getProfile({ userId: 'me' })); if (profile.data.historyId) await updateHistoryCheckpoint(userEmail, profile.data.historyId); return { found: false, replies: [], searchMetadata: { layer: "gmail-history", queriesRun: ["users.getProfile (reset)"], pagesChecked: 0, messagesScanned: 0, notes: "History checkpoint reset due to expired history" } }; } return { found: false, replies: [], searchMetadata: { layer: "gmail-history", queriesRun: [], pagesChecked: 0, messagesScanned: 0, notes: `Error: ${error?.message || 'Unknown error'}` } }; }
}
