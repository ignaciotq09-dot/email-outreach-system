import { db } from "../../db";
import { autoReplyLogs } from "@shared/schema";
import { detectIntentBulletproof } from "../../ai/bulletproof-intent-detection";
import { sendEmail as sendGmailEmail } from "../../gmail";
import { sendEmail as sendOutlookEmail } from "../../outlook";
import type { BulletproofAutoReplyResult } from "./types";
import { getAutoReplySettings } from "./settings";
import { sendUserNotification, sendReviewNotification } from "./notifications";

export async function processReplyForAutoResponse(userId: number, replyId: number, replyContent: string, contactId: number, contactEmail: string, contactName: string, originalSubject: string, provider: 'gmail' | 'outlook'): Promise<BulletproofAutoReplyResult> {
  try {
    const settings = await getAutoReplySettings(userId);
    if (!settings.enabled) { console.log(`[AutoReply] User ${userId}: Auto-reply is disabled`); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 500), intentConfidence: 0, intentType: 'disabled', status: 'skipped', errorMessage: 'Auto-reply is disabled' }); return { processed: true, autoReplySent: false, userNotified: false, flaggedForReview: false, intent: null }; }
    if (!settings.bookingLink) { console.log(`[AutoReply] User ${userId}: No booking link configured`); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 500), intentConfidence: 0, intentType: 'no_booking_link', status: 'skipped', errorMessage: 'No booking link configured' }); return { processed: true, autoReplySent: false, userNotified: false, flaggedForReview: false, intent: null, error: 'No booking link configured' }; }
    console.log(`[AutoReply] User ${userId}: Running bulletproof intent detection for reply ${replyId}`);
    const intent = await detectIntentBulletproof(replyContent);
    console.log(`[AutoReply] User ${userId}: Bulletproof detection complete - decision: ${intent.finalVerdict.decision}, confidence: ${intent.finalVerdict.confidence}%`);
    if (intent.finalVerdict.shouldFlagForReview) { console.log(`[AutoReply] User ${userId}: Flagging for manual review - ${intent.finalVerdict.reasoning}`); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 1000), intentConfidence: intent.finalVerdict.confidence, intentType: intent.pass1.intentType, autoReplyContent: null, status: 'flagged_for_review', pass1Result: JSON.stringify(intent.pass1), pass2Result: JSON.stringify(intent.pass2), patternValidation: JSON.stringify(intent.patternValidation), auditTrail: JSON.stringify(intent.auditTrail) }); const reviewNotified = await sendReviewNotification(userId, contactName, contactEmail, replyContent, intent.finalVerdict.reasoning, provider); return { processed: true, autoReplySent: false, userNotified: reviewNotified, flaggedForReview: true, intent }; }
    if (!intent.finalVerdict.shouldAutoReply) { console.log(`[AutoReply] User ${userId}: Not auto-replying - ${intent.finalVerdict.reasoning}`); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 1000), intentConfidence: intent.finalVerdict.confidence, intentType: intent.pass1.intentType, autoReplyContent: null, status: 'skipped', pass1Result: JSON.stringify(intent.pass1), pass2Result: JSON.stringify(intent.pass2), patternValidation: JSON.stringify(intent.patternValidation), auditTrail: JSON.stringify(intent.auditTrail) }); return { processed: true, autoReplySent: false, userNotified: false, flaggedForReview: false, intent }; }
    if (intent.patternValidation.hasConstraints || intent.patternValidation.hasQuestionLanguage) { console.log(`[AutoReply] User ${userId}: SAFETY CHECK - Constraints/questions detected despite auto_reply verdict, flagging instead`); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 1000), intentConfidence: intent.finalVerdict.confidence, intentType: intent.pass1.intentType, autoReplyContent: null, status: 'flagged_for_review', pass1Result: JSON.stringify(intent.pass1), pass2Result: JSON.stringify(intent.pass2), patternValidation: JSON.stringify(intent.patternValidation), auditTrail: JSON.stringify(intent.auditTrail), errorMessage: 'Safety check: Constraints/questions detected despite auto_reply verdict' }); return { processed: true, autoReplySent: false, userNotified: false, flaggedForReview: true, intent }; }
    const { generateAutoReplyMessage } = await import("../../ai/intent-detection"); const autoReplyContent = generateAutoReplyMessage(contactName, settings.bookingLink, settings.customMessage || undefined);
    const replySubject = originalSubject.startsWith('Re:') ? originalSubject : `Re: ${originalSubject}`;
    console.log(`[AutoReply] User ${userId}: CONFIRMED YES - Sending auto-reply to ${contactEmail}`);
    try { if (provider === 'outlook') { await sendOutlookEmail(userId, contactEmail, replySubject, autoReplyContent); } else { await sendGmailEmail(userId, contactEmail, replySubject, autoReplyContent); } } catch (sendError: any) { console.error(`[AutoReply] User ${userId}: Failed to send auto-reply:`, sendError.message); await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 1000), intentConfidence: intent.finalVerdict.confidence, intentType: intent.pass1.intentType, autoReplyContent, status: 'send_failed', pass1Result: JSON.stringify(intent.pass1), pass2Result: JSON.stringify(intent.pass2), patternValidation: JSON.stringify(intent.patternValidation), auditTrail: JSON.stringify(intent.auditTrail), errorMessage: sendError.message }); return { processed: true, autoReplySent: false, userNotified: false, flaggedForReview: false, intent, error: `Failed to send: ${sendError.message}` }; }
    await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent.substring(0, 1000), intentConfidence: intent.finalVerdict.confidence, intentType: intent.pass1.intentType, autoReplyContent, status: 'sent', pass1Result: JSON.stringify(intent.pass1), pass2Result: JSON.stringify(intent.pass2), patternValidation: JSON.stringify(intent.patternValidation), auditTrail: JSON.stringify(intent.auditTrail) });
    const userNotified = await sendUserNotification(userId, contactName, contactEmail, replyContent, autoReplyContent, provider);
    console.log(`[AutoReply] User ${userId}: Auto-reply sent successfully, user notified: ${userNotified}`);
    return { processed: true, autoReplySent: true, userNotified, flaggedForReview: false, intent };
  } catch (error: any) { console.error(`[AutoReply] User ${userId}: Error processing auto-reply:`, { error: error.message, stack: error.stack?.substring(0, 500), replyId, contactId, contactEmail, timestamp: new Date().toISOString() }); try { await db.insert(autoReplyLogs).values({ userId, replyId, contactId, originalReplyContent: replyContent?.substring(0, 500) ?? null, intentConfidence: 0, intentType: 'processing_error', autoReplyContent: null, status: 'error', errorMessage: `${error.message} | Stack: ${error.stack?.substring(0, 200) ?? 'N/A'}` }); } catch (logError) { console.error(`[AutoReply] User ${userId}: Failed to log error:`, logError); } return { processed: false, autoReplySent: false, userNotified: false, flaggedForReview: false, intent: null, error: error.message }; }
}
