import { db } from "../../../db";
import { replyDetectionDeadLetter, replyDetectionJobs, sentEmails, replies } from "@shared/schema";
import { eq } from "drizzle-orm";
import type { ReplyDetectionJobType } from "@shared/schema";

export async function handleRetry(entry: any, reviewedBy: number, notes?: string): Promise<{ success: boolean; message: string; newJobId?: number }> { const jobContext = entry.jobContext as any; const [newJob] = await db.insert(replyDetectionJobs).values({ userId: entry.userId, sentEmailId: entry.sentEmailId, contactId: entry.contactId, jobType: "manual_recheck" as ReplyDetectionJobType, provider: jobContext.provider, priority: 1, scheduledFor: new Date(), attempts: 0, maxAttempts: 3, metadata: { gmailThreadId: jobContext.gmailThreadId, gmailMessageId: jobContext.gmailMessageId, contactEmail: jobContext.contactEmail, contactName: jobContext.contactName, subject: jobContext.subject, sentAt: jobContext.sentAt, triggeredBy: `dead_letter_retry_${entry.id}` } }).returning(); await db.update(replyDetectionDeadLetter).set({ status: "retry_scheduled", reviewedAt: new Date(), reviewedBy, reviewAction: "retry", reviewNotes: notes, updatedAt: new Date() }).where(eq(replyDetectionDeadLetter.id, entry.id)); return { success: true, message: `Retry job ${newJob.id} created`, newJobId: newJob.id }; }

export async function handleManualCheck(entryId: number, reviewedBy: number, notes?: string): Promise<{ success: boolean; message: string }> { await db.update(replyDetectionDeadLetter).set({ status: "manually_checked", reviewedAt: new Date(), reviewedBy, reviewAction: "manual_check", reviewNotes: notes || "Manually verified by operator", updatedAt: new Date() }).where(eq(replyDetectionDeadLetter.id, entryId)); return { success: true, message: "Marked as manually checked" }; }

export async function handleSkip(entryId: number, reviewedBy: number, notes?: string): Promise<{ success: boolean; message: string }> { await db.update(replyDetectionDeadLetter).set({ status: "skipped", reviewedAt: new Date(), reviewedBy, reviewAction: "skip", reviewNotes: notes || "Skipped by operator", updatedAt: new Date() }).where(eq(replyDetectionDeadLetter.id, entryId)); return { success: true, message: "Entry skipped" }; }

export async function handleNoReply(entryId: number, sentEmailId: number, reviewedBy: number, notes?: string): Promise<{ success: boolean; message: string }> { await db.update(sentEmails).set({ replyReceived: false, lastReplyCheck: new Date() }).where(eq(sentEmails.id, sentEmailId)); await db.update(replyDetectionDeadLetter).set({ status: "resolved", reviewedAt: new Date(), reviewedBy, reviewAction: "mark_no_reply", reviewNotes: notes || "Confirmed no reply after manual check", updatedAt: new Date() }).where(eq(replyDetectionDeadLetter.id, entryId)); return { success: true, message: "Marked as no reply - detection confirmed" }; }

export async function handleHasReply(entry: any, reviewedBy: number, replyContent: string, notes?: string): Promise<{ success: boolean; message: string }> { await db.insert(replies).values({ sentEmailId: entry.sentEmailId, replyReceivedAt: new Date(), replyContent, gmailMessageId: `manual_${Date.now()}` }); await db.update(sentEmails).set({ replyReceived: true, lastReplyCheck: new Date() }).where(eq(sentEmails.id, entry.sentEmailId)); await db.update(replyDetectionDeadLetter).set({ status: "resolved", reviewedAt: new Date(), reviewedBy, reviewAction: "mark_has_reply", reviewNotes: notes || "Manually added reply that was missed", updatedAt: new Date() }).where(eq(replyDetectionDeadLetter.id, entry.id)); return { success: true, message: "Reply manually recorded" }; }
