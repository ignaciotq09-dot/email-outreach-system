import type { Request, Response } from "express";
import { storage } from "../../storage";
import { createGoogleOAuth2Client, GMAIL_SCOPES } from "../../auth/oauth-config";
import { encryptToken } from "../../auth/token-encryption";
import { google } from "googleapis";
import { replyDetectionEngine } from "../../services/reply-detection-engine";
import type { SessionData } from "./types";

export async function handleCallback(req: Request, res: Response) {
  const session = req.session as SessionData; const flowType = session.oauthFlow || "login"; const errorRedirect = flowType === "reconnect" ? "/app/settings" : "/login";
  try { const { code, state, error } = req.query; if (error) { console.error("[Gmail OAuth] Auth error from Google:", error); return res.redirect(`${errorRedirect}?error=google_auth_denied`); } if (!code || typeof code !== "string") { console.error("[Gmail OAuth] No authorization code received"); return res.redirect(`${errorRedirect}?error=no_auth_code`); } if (!state || state !== session.oauthState) { console.error("[Gmail OAuth] State mismatch"); return res.redirect(`${errorRedirect}?error=invalid_state`); }
  const oauth2Client = createGoogleOAuth2Client(req); const { tokens } = await oauth2Client.getToken(code); if (!tokens.access_token) { console.error("[Gmail OAuth] No access token received"); return res.redirect(`${errorRedirect}?error=no_access_token`); } oauth2Client.setCredentials(tokens); const oauth2 = google.oauth2({ version: "v2", auth: oauth2Client }); const userInfo = await oauth2.userinfo.get(); const email = userInfo.data.email; if (!email) { console.error("[Gmail OAuth] No email in user info"); return res.redirect(`${errorRedirect}?error=no_email`); }
  let user = await storage.getUserByEmail(email); const pendingInfo = session.pendingUserInfo;
  if (flowType === "reconnect") { if (!session.userId) return res.redirect("/login?error=not_authenticated"); user = await storage.getUserById(session.userId); if (!user) return res.redirect("/login?error=user_not_found"); } else if (flowType === "signup" && pendingInfo?.name) { if (!user) { console.log("[Gmail OAuth] Creating new user:", email); user = await storage.createUser({ email, name: pendingInfo.name, companyName: pendingInfo.companyName, position: pendingInfo.position, emailProvider: "gmail", profileImageUrl: userInfo.data.picture || null, roleId: null, active: true, lastLoginAt: new Date() }); } else { console.log("[Gmail OAuth] Updating existing user:", email); await storage.updateUser(user.id, { name: pendingInfo.name, companyName: pendingInfo.companyName, position: pendingInfo.position, emailProvider: "gmail", lastLoginAt: new Date() }); } } else { user = await storage.getUserByEmail(email); if (!user) { console.warn("[Gmail OAuth] Account not found:", email); return res.redirect("/signup?error=account_not_found"); } await storage.updateUserLastLogin(user.id); }
  const encryptedAccessToken = encryptToken(tokens.access_token); const encryptedRefreshToken = tokens.refresh_token ? encryptToken(tokens.refresh_token) : undefined; const expiresAt = tokens.expiry_date ? new Date(tokens.expiry_date) : new Date(Date.now() + 3600 * 1000); await storage.storeOAuthTokens({ userId: user.id, provider: "gmail", email, accessToken: encryptedAccessToken, refreshToken: encryptedRefreshToken, expiresAt, scope: tokens.scope || GMAIL_SCOPES.join(" ") }); console.log("[Gmail OAuth] Tokens stored for user:", user.id);
  delete session.pendingUserInfo; delete session.oauthState; delete session.oauthFlow; delete session.csrfToken; session.userId = user.id; try { await replyDetectionEngine.start(user.id, "gmail"); console.log("[Gmail OAuth] Reply detection engine started for user:", user.id); } catch (engineError) { console.error("[Gmail OAuth] Failed to start reply detection engine:", engineError); }
  const successRedirect = flowType === "reconnect" ? "/app/settings" : "/app"; console.log("[Gmail OAuth] Auth complete, redirecting to:", successRedirect); res.redirect(successRedirect); } catch (error) { console.error("[Gmail OAuth] Callback error:", error); res.redirect(`${errorRedirect}?error=oauth_callback_failed`); }
}
