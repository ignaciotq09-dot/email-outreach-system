import { db } from "../db";
import { eq } from "drizzle-orm";
import { sentEmails, replies, replyNotifications, appointmentRequests } from "@shared/schema";
import { sendSMS } from "../services/twilio";
import { detectAppointment } from "../services/openai";
import type { MonitoringResult } from "./types";

export async function processReply(replyData: { from: string; messageId: string; subject: string; content: string; receivedAt: Date }, contact: { id: number; name: string; email: string; company: string | null }, settings: any, result: MonitoringResult) {
  const [sentEmail] = await db.select().from(sentEmails).where(eq(sentEmails.contactId, contact.id)).orderBy(sentEmails.sentAt).limit(1); if (!sentEmail) { console.log(`[Monitor] No sent email found for contact ${contact.name}`); return; }
  const [existingReply] = await db.select().from(replies).where(eq(replies.gmailMessageId, replyData.messageId)).limit(1); if (existingReply) { console.log(`[Monitor] Reply already processed: ${replyData.messageId}`); return; }
  const [newReply] = await db.insert(replies).values({ sentEmailId: sentEmail.id, replyReceivedAt: replyData.receivedAt, replyContent: replyData.content, gmailMessageId: replyData.messageId }).returning(); console.log(`[Monitor] âœ“ New reply from ${contact.name}`); result.newReplies++;
  await db.update(sentEmails).set({ replyReceived: true, lastReplyCheck: new Date() }).where(eq(sentEmails.id, sentEmail.id));
  const [existingNotification] = await db.select().from(replyNotifications).where(eq(replyNotifications.replyId, newReply.id)).limit(1); if (!existingNotification && settings.smsPhoneNumber) { try { const smsContent = `ðŸ“§ Reply from ${contact.name} at ${contact.company}\n\nSubject: ${replyData.subject}\n\n${replyData.content.substring(0, 100)}...\n\nView in app: https://your-app.replit.app`; await sendSMS(settings.smsPhoneNumber, smsContent); await db.insert(replyNotifications).values({ replyId: newReply.id, contactId: contact.id, smsSent: true, smsDelivered: true }); console.log(`[Monitor] âœ“ SMS sent to ${settings.smsPhoneNumber}`); result.smsNotificationsSent++; } catch (smsError: any) { console.error(`[Monitor] SMS error:`, smsError); result.errors.push(`SMS failed for ${contact.name}: ${smsError.message}`); await db.insert(replyNotifications).values({ replyId: newReply.id, contactId: contact.id, smsSent: false, smsError: smsError.message }); } }
  try { const appointmentData = await detectAppointment(replyData.content, contact.name); const CONFIDENCE_THRESHOLD = 75; const hasRedFlags = appointmentData.redFlags && appointmentData.redFlags.length > 0; const meetsConfidenceThreshold = appointmentData.confidence >= CONFIDENCE_THRESHOLD; if (appointmentData.hasAppointment && meetsConfidenceThreshold && !hasRedFlags) { await db.insert(appointmentRequests).values({ replyId: newReply.id, contactId: contact.id, appointmentType: appointmentData.type, suggestedDate: appointmentData.suggestedDate, suggestedTime: appointmentData.suggestedTime, duration: appointmentData.duration, location: appointmentData.location, notes: appointmentData.notes, status: 'pending', aiConfidence: appointmentData.confidence, rawEmailText: replyData.content, platform: appointmentData.platform, detectionReason: appointmentData.detectionReason, redFlags: appointmentData.redFlags }); console.log(`[Monitor] âœ“ Appointment detected from ${contact.name} (confidence: ${appointmentData.confidence}%)`); result.appointmentsDetected++; } } catch (aiError: any) { console.error(`[Monitor] AI detection error:`, aiError); result.errors.push(`AI failed for ${contact.name}: ${aiError.message}`); }
}
